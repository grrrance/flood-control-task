Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Параметры запуска
Параметры располагаются в директории config/config-local.yml

- N == TimeLimit
- K == MaxRequests

Запрос:
``` curl http://localhost:9000/flood/user/{id}```

Ответ:
```json
{"is_triggered":true}
```

# Решение
Поскольку были мысли о том, что нужно хранить сессии запросов, было принято решение использовать Redis как хранилище. Так как Redis обладает высокой скоростью манипуляциями с данными, а также имеет возможность хранить сессию с TTL, что идеально ложилось на задачу.

Для взаимодействия с клиентом было выбрано http соединение.

Решением является счетчик запросов, если он достигает максимума, то последующие запросы не проходят контроль. По заданном моменту времени счетчик стирался с хранилища.
Для обеспечения потокобезопасности был использован мьютекс, хоть и функции над счетчиком атомарные, нужно было реализовать FloodControl транзакцией, поскольку без мьютекса могло произойти грязное чтение, что нарушило принципы ACID.

Было и другое решение, которое было сразу откинуто ввиду сложности реализации и неэффективности. Например, взять любую реляционную базу данных (допустим, PostgreSQL ) и создать также таблицу счетчиков, но строки еще будут содержить атрибут времени обозначающий старта отчета счетчика.
Таким образом мы бы каждый раз проверяли не только значение счетчика, но и его время, чтобы обновить его по истечению срока.

